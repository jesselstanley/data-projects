#!/usr/bin/env python
# coding: utf-8

# # Data Analysis on Android and iOS mobile apps
# 
# This research project is focused on all the apps that are available on Google Play and the Apple App Store. The data set contains information on a sample of at least 7200 applications which we will disect and analyse to reach the goal of this project.
# 
# We aim to provide insights on what type of apps are likely to attract more users. As the company we are working for offers its apps for free, and generates revenue through ads, it is important to understand which type of free apps are likely to generate the most traffic.

# In[1]:


open('AppleStore.csv', encoding='utf8')


# In[2]:


open('googleplaystore.csv', encoding='utf8')


# # Opening and Exploring the Data
# 
# As of September 2018, there were approximately 2 million iOS apps available on the App Store, and 2.1 million Android apps on Google Play.
# 
# For the purposes of this project, we will only be exploring a sample size of the above data.
# 
# 1. A data set containg data about approximately 10,000 Android apps from Google Play (the data was collected in August 2018) - [Found here](https://dq-content.s3.amazonaws.com/350/googleplaystore.csv")
# 2. A data set containing data about approximately 7,000 iOS apps from the App Store (the data was collected in July 2017) - [Found here](https://dq-content.s3.amazonaws.com/350/AppleStore.csv") 
# 

# In[3]:


from csv import reader

# The Google Play data set
opened_file = open('googleplaystore.csv')
read_file = reader(opened_file)
android = list(read_file)
android_header = android[0]
android = android[1:]

# The App Store data set
opened_file = open('AppleStore.csv')
read_file = reader(opened_file)
ios = list(read_file)
ios_header = ios[0]
ios = ios[1:]


# In[4]:


def explore_data(dataset, start, end, rows_and_columns=False):
    dataset_slice = dataset[start:end]    
    for row in dataset_slice:
        print(row)
        print('\n') # adds a new (empty) line between rows
        
    if rows_and_columns:
        print('Number of rows:', len(dataset))
        print('Number of columns:', len(dataset[0]))

print(android_header)
print('\n')
explore_data(android, 0, 3, True)


# Exploring the android apps on the Google Play Store data set shows that we have 10,841 apps, with 13 columns of specific data about each app.
# 
# The most interesting columns for us to focus on in this research in `App`, `Category`, `Installs`, `Price` and `Genres`. 

# In[5]:


print(ios_header)
print('\n')
explore_data(ios, 0, 3, True)


#  Exploring the iOS apps on the App Store data set shows that we have 7,197 apps, with 16 columns of specific data about each app.
#  
#  The most interesting columns for us to focus on in this research is `track_name`, `currency`, `price`, `user_rating` and `prime_genre`. More info about this data set, and column headers can be found in this data set  [documentation](https://www.kaggle.com/ramamet4/app-store-apple-data-set-10k-apps"). 

# ## Data Cleaning
# 
# In this section, I will focus on cleaning the data sets that have been presented above. This is an important step in insuring analytical accuracy throughout this project.
# 
# Firstly, I will:
# 
# 1. Detect inaccurate data, and correct or remove it.
# 2. Detect duplicate data, and remove the duplicates.
# 
# Secondly, in the research brief, our company states that they only build apps that are free to download and install. The main target audience of these applications is English-speaking. Thus, I will:
# 
# 1. Remove non-English apps like Áà±Â•áËâ∫PPS -„ÄäÊ¨¢‰πêÈ¢Ç2„ÄãÁîµËßÜÂâßÁÉ≠Êí≠.
# 2. Remove apps that aren't free.
# 
# ## Removing Incorrect Data
# 
# In this [discussion section](https://www.kaggle.com/lava18/google-play-store-apps/discussion") dedicated to our Google Play Store data set, I have noticed an error being mentioned for row 10472. I will validate this error, and remove it if necessary.

# In[6]:


print(android[10472]) #wrong data (discussion)
print('\n')
print(android_header) #header row
print('\n')
print(android[0]) #correct data


# As shown above, there is an error in row 10472 in the data set I have used. In the column 4, indicating number of reviews, the value is `1.9`, a string which goes against the general integer format of that column in the data set.

# In[7]:


del android[10472]

print(android[10472])


# This row has now been removed, and there is now longer an inconsistency in the format of the column position 4 in the data set.

# ## Removing Duplicate Data
# 
# ### Part One - Identifying Duplicates

# Spending more time reading over the Google Play Store data set has shown that there are duplicate entries that need to be removed.
# 
# An example of such duplicates will be shown below for the app `Instagram`:

# In[8]:


for app in android:
    name = app[0]
    if name == 'Instagram':
        print(app)


# As shown above, there are four duplicate entries for the app `Instagram`.

# I will highlight exactly how many duplicate apps appear in this data set below:

# In[9]:


duplicate_apps = []
unique_apps = []

for app in android:
    name = app[0]
    if name in unique_apps:
        duplicate_apps.append(name)
    else:
            unique_apps.append(name)
            
print('Number of duplicate apps:', len(duplicate_apps))
print('\n')
print('Examples of duplcate apps:', duplicate_apps[:15])


# We do not want duplicate data in our data set when we begin the analysis, because this will impact our accuracy come the end of this report.
# 
# When looking at the four entries for the app `Instagram` above, you will see that the main differentiating factor is the number of reviews, which appears in column position 4.
# 
# I will use this factor to remove the duplicates, so it is not done at random, by building a dictionary with only the app that has the most number of reviews - signifying that it was the latest entry for the app.

# ### Part Two - Removing Duplicates

# In[10]:


reviews_max = {}

for app in android:
    name = app[0]
    n_reviews = float(app[3])
    
    if name in reviews_max and reviews_max[name] < n_reviews:
        reviews_max[name] = n_reviews
        
    elif name not in reviews_max:
        reviews_max[name] = n_reviews


# Above, I showed that there are 1,181 cases of duplicate entries in this data set. So, once clean, the expected length of this data set should be the difference of the duplicate entries and the full data set of 10,841.

# In[11]:


print('Expected length:', len(android) - 1181)
print('Actual length:', len(reviews_max))


# Now that all duplicates have been removed from the dictionary `reviews_max`, I will use it to build two new dictionaries:
# 
# 1. `android_clean` - where all the new cleaned data set will be stored
# 2. `already_added` - which will just store app names

# In[12]:


android_clean = []
already_added = []

for app in android:
    name = app[0]
    n_reviews = float(app[3])
    
    if (reviews_max[name] == n_reviews) and (name not in already_added):
        android_clean.append(app)
        already_added.append(name)


# Just to demonstrate that the above is correct, I will show an example of the data set below, with the length to compare to the expected length above.

# In[13]:


explore_data(android_clean, 0, 3, True)


# We have 9,659 rows as expected.

# ### Part Three - Identifying non-English Apps
# 
# When exploring the data sets for both the `android` and `ios` apps, I have noticed multiple apps that are targeted at a non-English audience. Examples below:

# In[14]:


print(ios[813][1])
print(ios[6731][1])

print(android_clean[4412][0])
print(android_clean[7940][0])


# As our company only focuses on developing applications for an English audience only, we will have to remove apps from the data set that do not fit the criteria.
# 
# I will write a function that identifies chracters that are considered as non-English (as they fall outside the American Standard Code for Information Interchange guidelines of 1 - 127 being English characters)

# In[15]:


def english_apps(string):
    
    for character in string:
        if ord(character) > 127:
            return False

    return True

print(english_apps('Instagram'))
print(english_apps('Áà±Â•áËâ∫PPS -„ÄäÊ¨¢‰πêÈ¢Ç2„ÄãÁîµËßÜÂâßÁÉ≠Êí≠'))
print(english_apps('Docs To Go‚Ñ¢ Free Office Suite'))
print(english_apps('Instachat üòú'))


# As seen above, the function works as expected, however it incorrectly indentifies app_names with characters like `‚Ñ¢` and `üòú` as being non-english.
# 
# Using the function as is will lead to us removing useful data from our data set.

# #### Solution

# The solution for this, is to assess whether there are more than 3 non-english (ASCII 0 - 127) characters in a string.
# 
# I have reformulated the function from the code above to reflect that change.

# In[16]:


def is_english(string):
    non_ascii = 0
    
    for character in string:
        if ord(character) > 127:
            non_ascii += 1
    
    if non_ascii > 3:
        return False
    else:
        return True

print(is_english('Docs To Go‚Ñ¢ Free Office Suite'))
print(is_english('Instachat üòú'))


# This works as expected, correctly labelling `Docs To Go‚Ñ¢ Free Office Suite` and `Instachat üòú` as English apps.

# In[17]:


android_english = []
ios_english = []

for app in android_clean:
    name = app[0]
    if is_english(name):
        android_english.append(app)
        
for app in ios:
    name = app[1]
    if is_english(name):
        ios_english.append(app)
        
explore_data(android_english, 0, 3, True)
print('\n')
explore_data(ios_english, 0, 3, True)


# After exploring the two data sets, and removing duplicates, incorrect data, and non-english apps, we see:
# 
# 1. A total of 9,614 apps to analyse in the `android` data set
# 2. A total of 6,183 apps to analyse in the `ios` data set

# The last step in cleaning the two data sets is to seperate the non-free apps from the free apps. 
# 
# As our company only releases free apps, and generates revenue from in-app ads, the non-free apps are irrelevant for this analysis.

# In[18]:


android_final = []
ios_final = []

for app in android_english:
    price = app[7]
    if price == '0':
        android_final.append(app)
        
for app in ios_english:
    price = app[4]
    if price == '0.0':
        ios_final.append(app)
        
print(len(android_final))
print(len(ios_final))


# After cleaning the data, and ensuring we are only analysing relevant data, we are left with a total of:
# 
# 1. 8,864 free, english-only apps in the `android` data set
# 2. 3,222 free, english-only apps in the `ios` data set
# 
# This will be sufficient for our analysis.

# # Data Analysis
# 
# In this section we will begin analysing the data we have cleaned previously. The goal is to identify the kids of apps that are likely to attract more users because our revenues (ad-revenue) is influenced by the number of people using our apps.
# 
# In order to minimize risks and overhead at our company when building apps, our validation strategy for an app idea is comprised of three steps:
# 
# 1. Build a minimal Android version of the app, and add it to Google Play.
# 2. If the app has a good response from users, we develop it further.
# 3. If the app is profitable after six months, we build an iOS version of the app and add it to the App Store.
# 
# Hence why we need to analyse the apps that would be successful on both the Google Play Store and the App Store.

# ## Frequency Table - Share of Apps 
# 
# Below, I will inspect the header rows of each data set to determine which columns are relevant to generate frequency tables for our analysis:

# In[22]:


print(android_header)
print('\n')
print(ios_header)


# The data I will use for the frequency tables are:
# 
# 1. **Google Play Store** - the `Category` and `Genres` columns.
# 
# 1. **App Store** - the `prime_genre` column.
# 
# I will build two functions to build the frequency table:
# 
# - One function to build the frequency table and show results in a percentage format.
# 
# - A second function to display the results in descending order.

# In[26]:


def freq_table(dataset, index):
    table = {}
    total = 0
    
    for row in dataset:
        total += 1
        value = row[index]
        if value in table:
            table[value] += 1
        else:
             table[value] = 1
            
    table_percentages = {}
    for key in table:
        percentage = (table[key] / total) * 100
        table_percentages[key] = percentage

    return table_percentages


def display_table(dataset, index):
    table = freq_table(dataset, index)
    table_display = []
    for key in table:
        key_val_as_tuple = (table[key], key)
        table_display.append(key_val_as_tuple)

    table_sorted = sorted(table_display, reverse = True)
    for entry in table_sorted:
        print(entry[1], ':', entry[0])


# ### Frequency Tables
# 
# Now that the function has been defined, I will use it to build the frequency tables for both data sets (Play Store and App Store).
# 
# Starting with the iOS apps on the App Store (free English apps only):

# In[27]:


display_table(ios_final, -5)


# The above shows that 58% of all iOS apps on the App Store are Games, the largest majority in our data set by a large margin. Followed by Entertainment with an 8% share and Photo & Video with a 5% share. Apps for specific purposes such as Education and Social Networking are both around the 3% mark. The data shows that the majority of apps on the App Store are for entertainment purposes (Games, Entertainment, Photos and Video, Sports, Music, Health & Fitness, etc). 
# 
# Next, I will apply the function to build the frequency tables for the Android apps in the Google Play Store (free English apps only):

# In[30]:


display_table(android_final, 1) #category


# The Google Play data set shows a slightly different picture than that of the App Store data set. Here we see 19% of all apps being under the rather generic Category `FAMILY`, with `GAME` at 9.7% and `TOOLS` at 8.4%. 
# 
# There seems to be more apps for specific purposes such as `TOOLS`, `BUSINESS` and `PRODUCTIVITY` on the Play Store than on the App Store.
# 
# However, as we can see in this image, the category `FAMILY` (which accounts for 19% of all apps on the Play Store consists mostly of games for children.
#  
# ![alt text](https://www.lowyat.net/wp-content/uploads/2015/06/Google-Play-Store-Family-Category.jpg)
# 
# Now, for the Genres column:

# In[32]:


display_table(android_final, -4) #genres


# It is not abundantly clear what the difference is between the Category and Genres columns. However, the data is on a more granular level in the Genres column.
# 
# Here, we see that Tools has the most share of apps on the Play Store at 8.5%, followed by Entertainment at 6% and Education at 5.3%.
# 
# It is important to note for all the above data that a higher % of apps in a certain genre does not necessarily indicate popularity, that will be analysed in the next section. 

# ## Frequency Table - Most popular apps by Genre
# 
# Below, I will analyse the data that shows the popularity of apps based on interactons with the application.
# 
# - For the Android Google Play Store data set we will use the information found in the `Installs` column
# 
# - For the iOS App Store data set we will use a workaround as there is no column that clear illustrates the number of downloads. I will use the column `rating_count_tot` as a proxy for downloads (this column the number of user ratings).

# ## iOS App Store
# 
# Firstly, we will look into the iOS App Store data set, as I need to do the following in order to determine the number of user ratings per genre (we are using user ratings as a proxy for number of downloands):
# 
# - Isolate the apps of each genre.
# - Sum up the user ratings for the apps of that genre.
# - Divide the sum by the number of apps belonging to that genre (not by the total number of apps).

# In[38]:


genres_ios = freq_table(ios_final, -5)

for genre in genres_ios:
    total = 0
    len_genre = 0
    for app in ios_final:
        genre_app = app[-5]
        if genre_app == genre:
            n_ratings = float(app[5])
            total += n_ratings
            len_genre += 1
    avg_n_ratings = total / len_genre
    print(genre, ':', avg_n_ratings)


# From the above data, we can see that `Navigation` apps are the most popular genre on the App Store. However, this is greatly influenced by two widely used applications, Waze and Google Maps which have nearly half a million reviews between them.

# In[45]:


for app in ios_final:
    if app[-5] == "Navigation":
        print(app[1], ':', app[5])


# We can see the same pattern with `Social Network` apps on the iOS App Store where popular apps such as Facebook, WhatsApp Messenger, Messenger, Tumblr and Skype for iPhone have a majority of the reviews.

# In[46]:


for app in ios_final:
    if app[-5] == "Social Networking":
        print(app[1], ':', app[5])


# As these two genres seem to be dominated by some of the major players as mentioned above, I do not suggest these two genres as focus points for developig free applications for our company.

# The two genres that I have identified as being particularly interesting are the `Reference` and `Book` genres, which are not skewed by major players such as the examples above.

# In[47]:


for app in ios_final:
    if app[-5] == "Reference":
        print(app[1], ':', app[5])


# In[52]:


for app in ios_final:
    if app[-5] == "Book":
        print(app[1], ':', app[5])


# These two genres are not saturated with too many major players, and the popularity of the genres show a possible opportunity for a new entrant.

# ## Google Play Store
# 
# Now we will look into the Google Play Store data set. However, before the analysis I have noticed that the format of the data is slightly different to what is needed.

# In[53]:


display_table(android_final, 5) #the Installs column


# As seen above, the data consists of approximate ranges (100,000+ for example), which is okay as we do not need exact numbers to determine the most popular apps.
# 
# However, we will need to remove the `,` and `+` from the data so that it can be converted from a string to a float.

# In[62]:


category_android = freq_table(android_final, 1)

for category in category_android:
    total = 0
    len_category = 0
    for app in android_final:
        category_app = app[1]
        if category_app == category:
            n_installs = app[5]
            n_installs = n_installs.replace("+", "")
            n_installs = n_installs.replace(",", "")
            total += float(n_installs)
            len_category += 1
        
    avg_n_installs = total / len_category
    print(category, ':', avg_n_installs)


# Looking at the data above, there are a few genres that stand out in terms of downloads. However, the major stand out number is that of `COMMUNICATION` with 38,456,119 downloads. Diving into this genre shows a dominance of a few major players, which significantly skews the cohort.

# In[63]:


for app in android_final:
    if app[1] == 'COMMUNICATION' and (app[5] == '1,000,000,000+'
                                      or app[5] == '500,000,000+'
                                      or app[5] == '100,000,000+'):
        print(app[0], ':', app[5])


# With the likes of WhatsApp Messenger, Messenger, Skype, Google Chrome, Gmail and Hangouts all having over 1,000,000 installs, it inflates the average install per application by a significant margin.
# 
# These are massive players in their respective markets that will be difficult to compete against.

# Further investigating the most popular categories above, I have identified the category `BOOKS_AND_REFERENCE` with an average of 8,767,811 installs per application. The distribution of these installs is as follows:

# In[66]:


for app in android_final:
    if app[1] == 'BOOKS_AND_REFERENCE':
        print(app[0], ':', app[5])


# This genre has a clearer distribution of installs across the data, with there being only handful of applications with over 1,000,000 installs:

# In[67]:


for app in android_final:
    if app[1] == 'BOOKS_AND_REFERENCE' and (app[5] == '1,000,000,000+'
                                      or app[5] == '500,000,000+'
                                      or app[5] == '100,000,000+'):
        print(app[0], ':', app[5])


# This genre presents an opportunity to the company as there are fewer large players preventing new entrants into the market, and the average number of installs per application is high.
# 
# Further, it seems that this niche market is dominated by e-Readers and digital versions of dictionaries. So I advised against creating either of those two types of apps as there is considerable competition already.
# 
# However, digital versions of popular books such as the Bible, the Quran and other popular books have an even ditribution of downloads across the niche. I would advise creating an app that is a digital version of a newer popular book, but with additional features that sets it apart from the rest of the competition.

# # Conclusion

# In conclusion, this project's focus was to analyse apps across the iOS App Store and the Google Play Store with the goal of identifying the most profitable genre for free English-targeted applications.
# 
# I have advised on creating an app that is a digital version of a popular book, but with additional features that sets it apart from the rest of the competition. This app would prove popular in both app stores based on the data set we have analysed, with the Book and Reference genre being popular in both stores.
